## Практические задания для самостоятельного выполнения Словари и Функции. №9
- ### Начальный уровень
  - #### Задание №1
    Напишите программу на tkinter
    1. Заголовок программы (label), к примеру "Hello, World!"
    2. Поле ввода, в которое будет вводиться значение
    3. Кнопка "Вывести", которая при нажатии отобразит в новом окне или ниже поля ввода слова, которые ввели в поле перед этим.
    3.1 Дополнительно: эта функция исполниться, если при вводе в поле нажать enter


- ### Базовый уровень
  - #### Задание №1
    Напишите программу на tkinter
    1. Заголовок программы (label), к примеру "Hello, World!"
    2. Поле ввода, в которое будет вводиться значение
    3. Кнопка "Вывести", которая при нажатии отобразит в новом окне или ниже поля ввода слова, которые ввели в поле перед этим.
    3.1 Дополнительно: эта функция исполниться, если при вводе в поле нажать enter
    4. Кнопка "Очистить", которая при нажатии будет очищать поле ввода и удалять выведенные слова.


## Примеры ввода/вывода 
- ### Начальный уровень
  - #### Задание №1
    | Ввод  | Вывод |
    |:------------------------:|:---------------:|
    | Hello, World <br> Нажатие кнопки "Вывести" | ![begin-gif](./resources/automation_begin.gif) |
- ### Базовый уровень
  - #### Задание №1
    | Ввод  | Вывод |
    |:------------------------:|:---------------:|
    | Hello, World <br> Нажатие кнопки "Вывести" <br> Нажатие кнопки "Очистить" | ![basic-gif](./resources/automation_basic.gif) |

## Алгоритмы решения
- ### Начальный уровень
  - #### Задание №1
    1. Импортируем модуль tkinter и сокращаем название до tk
    ```py
    import tkinter as tk
    ```
    2. Теперь создаем класс и в качестве родителя выбираем виджет Frame (это как отдельное окно, белый прямоугольный *лист*)
    ```py
    '''
    Немного о теории
    Класс - это объект в Python
    Родитель - это класс от которого наследуются свойства в другой класс
    Методы - это функции в классе
    Атрибут - это переменная в классе
    self - это ключевое слово для обращению к классу внутри класса (т. е. самого себя)
    '''
    '''
    В данном случае мы создаем пустой класс с именем MainWindow.
    Он имеет класс-родитель tk.Frame, т. е. свойства MainWindow = свойства tk.Frame
    '''
    class MainFrame(tk.Frame):
      pass
    ```
    3. Инициализируем класс MainWindow
    ```py
    class MainFrame(tk.Frame):
      # Метод инициализации класса 
      def __init__(self, master):
          # инициализируем родительский класс, в котором окно для прикрепления будет аргумент из __init__
          super().__init__(master)
    ```
    5. Добавляем метод setupUI, в котором мы будем устанавливать интерфейс программы
    ```py
    class MainFrame(tk.Frame):
      def __init__(self, master):
          super().__init__(master)
          # вызываем функцию
          self.setupUI()

      def setupUI(self):
        pass
    ```
    6. Определяем переменные в которых будут храниться заголовок, поле ввода, текст вывода, кнопка вывода 
    ```py
    class MainFrame(tk.Frame):
      def __init__(self, master):
          super().__init__(master)
          # вызываем функцию
          self.setupUI()

      def setupUI(self):
        '''
        Создаем строку или же лейбл (заголовок), находящийся в окне (self)
        С текстом "Привет мир" (text="Привет, мир!")
        C шрифтом Times New Roman и размером 16 (font="Times 16")
        Делаем отступы с осей x (pdax=20) и y (pady=25)
        '''
        self.hello_label = tk.Label(self, text="Привет, мир!", font="Times 16", padx=20, pady=25)
        '''
        Создаем поле ввода, находящееся в окне (self)
        С рамками толщиной 3 (border=3)
        C шрифтом Times New Roman и размером 14 (font="Times 14")
        '''
        self.input_text = tk.Entry(self, border=3, font="Times 14")
        '''
        Создаем лейбл (текст вывода), находящийся в окне (self)
        Делаем отступ оси y (pady=1)
        '''
        self.answer_text = tk.Label(self, pady=1)
        '''
        Создаем кнопку, находящуюся в окне (self)
        С текстом "Вывести" (text="Вывести")
        C шириной 15 и высотой 2 (width=15, height=2)
        И анонимной функцией при нажатии (command=lambda: ...)
        Анонимная функция не принимает аргументов и ничего возращает
        С помощью метода config меняем text
        self.input_text.get() - получить текст поля ввода
        '''
        self.button_print = tk.Button(self, text="Вывести", width=15, height=2, command=lambda: self.answer_text.config(text=self.input_text.get()))
        '''
        Задаем функцию при нажатии Enter в поле ввода.
        Сама функция анонимная и принимает 1 аргумент, который не записывает и ничего не возращает
        С помощью метода config меняем text
        '''
        self.input_text.bind('<Return>', lambda _: self.answer_text.config(text=self.input_text.get()))
        # при запуске программы мы делаем фокус на поле ввода, т. е. нажимать курсором, чтоб ввести данные не нужно
        self.input_text.focus()
        # перебираем каждый элемент в списке всех элементов интерфейса
        for element in [self.hello_label, self.input_text, self.answer_text, self.button_print]:
            # располагаем в окне элемент
            element.pack()
    ```
    7. Определяем окно программы и располагаем в окне экземпляр класса Frame
    ```py
    # Если импортировать этот файл как модуль, то код, который в этом блоке не исполниться
    # А если открыть этот файл напрямую, то код, который в этом блоке исполниться
    if __name__ == '__main__':
      # Определяем переменную (окно программы)
      app = tk.Tk(className="Начальный уровень")
      # С помощью метода geometry устанавливаем размер окна 300 на 200
      app.geometry("300x200")
      # Располагаем в окне Frame
      MainFrame(app).pack()
      # Чтоб графическое приложение отображалось в режиме реального времени, т. е. повторялся с помощью цикла отображение окна
      app.mainloop()
    ```
- ### Базовый уровень
  - #### Задание №1
     1. Импортируем модуль tkinter и сокращаем название до tk
    ```py
    import tkinter as tk
    ```
    2. Теперь создаем класс и в качестве родителя выбираем виджет Frame (это как отдельное окно, белый прямоугольный *лист*)
    ```py
    '''
    Немного о теории
    Класс - это объект в Python
    Родитель - это класс от которого наследуются свойства в другой класс
    Методы - это функции в классе
    Атрибут - это переменная в классе
    self - это ключевое слово для обращению к классу внутри класса (т. е. самого себя)
    '''
    '''
    В данном случае мы создаем пустой класс с именем MainWindow.
    Он имеет класс-родитель tk.Frame, т. е. свойства MainWindow = свойства tk.Frame
    '''
    class MainFrame(tk.Frame):
      pass
    ```
    3. Инициализируем класс MainWindow
    ```py
    class MainFrame(tk.Frame):
      # Метод инициализации класса 
      def __init__(self, master):
          # инициализируем родительский класс, в котором окно для прикрепления будет аргумент из __init__
          super().__init__(master)
    ```
    5. Добавляем метод setupUI, в котором мы будем устанавливать интерфейс программы
    ```py
    class MainFrame(tk.Frame):
      def __init__(self, master):
          super().__init__(master)
          # вызываем функцию
          self.setupUI()

      def setupUI(self):
        pass
    ```
    6. Определяем переменные в которых будут храниться заголовок, поле ввода, текст вывода, кнопка вывода и очистки. Пишем функцию очистки ввода.
    ```py
    class MainFrame(tk.Frame):
      def __init__(self, master):
          super().__init__(master)
          # вызываем функцию
          self.setupUI()

      def setupUI(self):
        '''
        Создаем строку или же лейбл (заголовок), находящийся в окне (self)
        С текстом "Привет мир" (text="Привет, мир!")
        C шрифтом Times New Roman и размером 16 (font="Times 16")
        Делаем отступы с осей x (pdax=20) и y (pady=25)
        '''
        self.hello_label = tk.Label(self, text="Привет, мир!", font="Times 16", padx=20, pady=25)
        '''
        Создаем поле ввода, находящееся в окне (self)
        С рамками толщиной 3 (border=3)
        C шрифтом Times New Roman и размером 14 (font="Times 14")
        '''
        self.input_text = tk.Entry(self, border=3, font="Times 14")
        '''
        Создаем лейбл (текст вывода), находящийся в окне (self)
        Делаем отступ оси y (pady=1)
        '''
        self.answer_text = tk.Label(self, pady=1)
        '''
        Создаем кнопку, находящийся в окне (self)
        С текстом "Вывести" (text="Вывести")
        C шириной 15 и высотой 2 (width=15, height=2)
        И анонимной функцией при нажатии (command=lambda: ...)
        Анонимная функция не принимает аргументов и ничего возращает
        С помощью метода config меняем text
        self.input_text.get() - получить текст поля ввода
        '''
        self.button_print = tk.Button(self, text="Вывести", width=15, height=2, command=lambda: self.answer_text.config(text=self.input_text.get()))
        '''
        Создаем кнопку, находящуюся в окне (self)
        С текстом "Очистить" (text="Очистить")
        C шириной 15 и высотой 2 (width=15, height=2)
        С методом clear_input при нажатии кнопки (command=self.clear_input)
        '''
        self.button_clear = tk.Button(self, text="Очистить", width=15, height=2, command=self.clear_input)
        '''
        Задаем функцию при нажатии Enter в поле ввода.
        Сама функция анонимная и принимает 1 аргумент, который не записывает и ничего не возращает
        С помощью метода config меняем text
        '''
        self.input_text.bind('<Return>', lambda _: self.answer_text.config(text=self.input_text.get()))
        # при запуске программы мы делаем фокус на поле ввода, т. е. нажимать курсором, чтоб ввести данные не нужно
        self.input_text.focus()
        # перебираем каждый элемент в списке всех элементов интерфейса, кроме кнопок
        for element in [self.hello_label, self.input_text, self.answer_text]:
            # располагаем в окне элемент
            element.pack()
        # перебираем каждый элемент и индекс в списке кнопок
        for i, button in enumerate([self.button_print, self.button_clear]):
            # размещаем кнопку относительно по оси x, y и добавляем (0.45 * индекс) в центре
            button.place(relx=0.3 + (0.45 * i), rely=0.75, anchor="center")

      def clear_input(self):
          # С помощью self получаем атрибут answer_text и с помощью метода config ставим пустой текст
          self.answer_text.config(text='')
          # С помощью self получаем атрибут input_text и с помощью метода delete в первом аргументе 0 (первый символ) и "end" (последний символ), т. е. удалить текст в поле ввода от начала до конца
          self.input_text.delete(0, "end")
    ```
    7. Определяем окно программы и располагаем в окне экземпляр класса Frame
    ```py
    # Если импортировать этот файл как модуль, то код, который в этом блоке не исполниться
    # А если открыть этот файл напрямую, то код, который в этом блоке исполниться
    if __name__ == '__main__':
      # Определяем переменную (окно программы)
      app = tk.Tk(className="Начальный уровень")
      # С помощью метода geometry устанавливаем размер окна 300 на 200
      app.geometry("300x200")
      # Располагаем в окне Frame
      MainFrame(app).pack()
      # Чтоб графическое приложение отображалось в режиме реального времени, т. е. повторялся с помощью цикла отображение окна
      app.mainloop()
  ```
